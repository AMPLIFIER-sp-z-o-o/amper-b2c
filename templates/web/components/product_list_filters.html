{% load i18n %}
<div id="{% if is_mobile %}filters-sidebar-mobile{% else %}filters-sidebar{% endif %}" class="filters-sidebar">
  
  <!-- Subcategories Navigation -->
  {% if current_category and subcategories_nav %}
  <div class="mb-6">
    <!-- Parent Category Link -->
    {% if current_category.parent %}
    <a id="filters-parent-category-link-{{ current_category.parent.id }}{% if is_mobile %}-mobile{% endif %}" href="{{ current_category.parent.get_absolute_url }}" class="flex items-center gap-2 mb-1 text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg px-3 py-2 transition-colors cursor-pointer group">
      <svg class="w-4 h-4 transition-transform group-hover:-translate-x-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
      </svg>
      <span>{{ current_category.parent.name }}</span>
      {% if parent_category_product_count %}<span class="text-gray-600 dark:text-gray-400 font-medium">({{ parent_category_product_count }})</span>{% endif %}
    </a>
    {% endif %}
    
    <!-- Current Category Name -->
    <div id="filters-current-category-{{ current_category.id }}{% if is_mobile %}-mobile{% endif %}" class="mb-2">
      <span class="text-base font-bold text-gray-900 dark:text-white">{{ current_category.name }}</span>
      <span id="{% if is_mobile %}category-product-count-mobile{% else %}category-product-count{% endif %}" class="text-sm text-gray-600 dark:text-gray-400 ml-1 font-medium">({{ total_count }})</span>
    </div>
    
    <!-- Subcategories List -->
    <ul class="space-y-0.5 mt-1 {% if is_mobile %}-mx-3{% else %}-mx-4{% endif %}">
      {% for subcategory in subcategories_nav %}
      <li id="filters-subcategory-item-{{ subcategory.id }}{% if is_mobile %}-mobile{% endif %}">
        <a id="filters-subcategory-link-{{ subcategory.id }}{% if is_mobile %}-mobile{% endif %}" href="{{ subcategory.get_absolute_url }}" class="block py-1.5 {% if is_mobile %}ps-8 pe-3{% else %}ps-10 pe-4{% endif %} text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors">
          {{ subcategory.name }}
          {% if subcategory.total_product_count %}<span class="text-gray-600 dark:text-gray-400 font-medium">({{ subcategory.total_product_count }})</span>{% endif %}
        </a>
      </li>
      {% endfor %}
    </ul>
  </div>
  {% endif %}

  <!-- Parent Category Navigation (when no subcategories) -->
  {% if current_category and current_category.parent and not subcategories_nav %}
  <a id="filters-parent-category-link-{{ current_category.parent.id }}{% if is_mobile %}-mobile{% endif %}" href="{{ current_category.parent.get_absolute_url }}" class="flex items-center gap-2 mb-4 text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg px-3 py-2 transition-colors cursor-pointer group">
    <svg class="w-4 h-4 transition-transform group-hover:-translate-x-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
    </svg>
    <span>{{ current_category.parent.name }}</span>
    {% if current_category.parent.product_count %}<span class="text-gray-600 dark:text-gray-400 font-medium">({{ current_category.parent.product_count }})</span>{% endif %}
  </a>
  {% endif %}

  {% if not is_mobile %}
  <!-- Hidden form for filter submission -->
  <form id="desktop-filter-form" action="" method="get" class="hidden">
    {% if search_query %}<input type="hidden" name="q" value="{{ search_query }}">{% endif %}
    {% if current_sort and current_sort != 'relevance' %}<input type="hidden" name="sort" value="{{ current_sort }}">{% endif %}
  </form>

  <!-- Filters Header with Clear Link -->
  <div class="flex items-center justify-between mb-4">
    <h2 class="text-xl font-bold text-gray-900 dark:text-white">{% trans "Filters" %}</h2>
     <a href="{% if current_category %}{{ current_category.get_absolute_url }}{% elif is_search_page %}{% url 'web:search_results' %}{% else %}{% url 'web:product_list' %}{% endif %}{% if search_query %}?q={{ search_query }}{% endif %}" 
       id="clear-filters-link"
       data-clear-all-filters
       data-soft-nav="false"
       data-base-url="{% if current_category %}{{ current_category.get_absolute_url }}{% elif is_search_page %}{% url 'web:search_results' %}{% else %}{% url 'web:product_list' %}{% endif %}"
      class="inline-flex items-center rounded-lg px-3 py-2 text-xs transition-all hover:bg-gray-200 dark:hover:bg-gray-700 {% if selected_attributes or current_price_min or current_price_max %}text-gray-900 dark:text-white font-bold cursor-pointer{% else %}text-gray-400 dark:text-gray-500 pointer-events-none cursor-default{% endif %}">
      {% trans "Clear all" %}
    </a>
  </div>

  <!-- Filter Search Input -->
  <div class="mb-4">
    <div class="relative">
      <div class="pointer-events-none absolute inset-y-0 start-0 flex items-center ps-3">
        <svg class="h-4 w-4 text-gray-500 dark:text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
          <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z" />
        </svg>
      </div>
      <input type="text" id="filter-search-input" class="block w-full rounded-lg border-none bg-gray-100 px-4 py-2.5 ps-10 text-sm font-medium text-gray-900 focus:bg-white focus:ring-0 focus:shadow-[0_4px_8px_0_rgba(0,0,0,0.16),0_0_2px_1px_rgba(0,0,0,0.08)] dark:bg-gray-700 dark:text-white dark:placeholder:text-gray-400 dark:focus:bg-gray-600 dark:focus:shadow-[0_4px_10px_-2px_rgb(0_0_0/0.5)] transition-all duration-150" placeholder="{% trans 'Search filters...' %}" />
    </div>
  </div>
  {% endif %}

  <div id="{% if is_mobile %}accordion-flush-mobile{% else %}accordion-flush{% endif %}">
    
    <!-- Search Box (for mobile filter drawer) -->
    {% if is_mobile and search_query %}
    <div class="mb-4">
      <label for="mobile-search" class="sr-only">{% trans "Search" %}</label>
      <div class="relative">
        <div class="pointer-events-none absolute inset-y-0 start-0 flex items-center ps-3">
          <svg class="h-4 w-4 text-gray-500 dark:text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z" />
          </svg>
        </div>
        <input type="search" name="q" id="mobile-search" value="{{ search_query }}" class="block w-full rounded-lg border-none bg-gray-100 px-4 py-2.5 ps-10 text-sm font-medium text-gray-900 focus:bg-white focus:ring-0 focus:shadow-[0_4px_8px_0_rgba(0,0,0,0.16),0_0_2px_1px_rgba(0,0,0,0.08)] dark:bg-gray-700 dark:text-white dark:placeholder:text-gray-400 dark:focus:bg-gray-600 dark:focus:shadow-[0_4px_10px_-2px_rgb(0_0_0/0.5)] transition-all duration-150" placeholder="{% trans 'Search products...' %}" />
      </div>
    </div>
    {% endif %}

    <!-- Price Filter -->
    <div class="filter-group py-2 border-b border-gray-100 dark:border-gray-800" data-filter-name="{% trans 'Price' %}">
      <h2 id="accordion-flush-heading-price{% if is_mobile %}-mobile{% endif %}">
        <button type="button" class="flex w-full items-center justify-between font-semibold text-gray-900 hover:text-primary-700 dark:text-white dark:hover:text-primary-500 rtl:text-right cursor-pointer" data-accordion-target="#accordion-flush-body-price{% if is_mobile %}-mobile{% endif %}" aria-expanded="true" aria-controls="accordion-flush-body-price{% if is_mobile %}-mobile{% endif %}">
          <span class="text-base">{% trans "Price" %}</span>
          <svg data-accordion-icon class="h-5 w-5 shrink-0 rotate-180" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 15 7-7 7 7" />
          </svg>
        </button>
      </h2>
      <div id="accordion-flush-body-price{% if is_mobile %}-mobile{% endif %}" class="mt-4" aria-labelledby="accordion-flush-heading-price{% if is_mobile %}-mobile{% endif %}">
        <div class="flex items-center gap-2">
          <!-- Min Price Input -->
          <div class="flex-1 flex items-center justify-center border-none rounded-full px-4 py-2 bg-gray-100 dark:bg-gray-700 transition-all focus-within:bg-white focus-within:shadow-[0_4px_8px_0_rgba(0,0,0,0.16),0_0_2px_1px_rgba(0,0,0,0.08)] dark:focus-within:bg-gray-600 dark:focus-within:shadow-[0_4px_10px_-2px_rgb(0_0_0/0.5)]">
            <input type="number" 
                   name="price_min" 
                   id="price_min{% if is_mobile %}_mobile{% endif %}" 
                   value="{{ current_price_min }}"
                   placeholder="{% trans 'from' %}"
                   min="0"
                   step="0.01"
                   class="w-full border-0 bg-transparent p-0 text-sm text-gray-900 dark:text-white text-center placeholder:text-center placeholder:text-gray-400 dark:placeholder:text-gray-500 focus:ring-0 focus:outline-none appearance-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none" />
            <span class="text-sm text-gray-400 dark:text-gray-500 ml-1 shrink-0">{% if site_currency == 'USD' %}${% else %}{{ site_currency }}{% endif %}</span>
          </div>
          <!-- Separator -->
          <span class="text-gray-400 dark:text-gray-500">—</span>
          <!-- Max Price Input -->
          <div class="flex-1 flex items-center justify-center border-none rounded-full px-4 py-2 bg-gray-100 dark:bg-gray-700 transition-all focus-within:bg-white focus-within:shadow-[0_4px_8px_0_rgba(0,0,0,0.16),0_0_2px_1px_rgba(0,0,0,0.08)] dark:focus-within:bg-gray-600 dark:focus-within:shadow-[0_4px_10px_-2px_rgb(0_0_0/0.5)]">
            <input type="number" 
                   name="price_max" 
                   id="price_max{% if is_mobile %}_mobile{% endif %}" 
                   value="{{ current_price_max }}"
                   placeholder="{% trans 'to' %}"
                   min="0"
                   step="0.01"
                   class="w-full border-0 bg-transparent p-0 text-sm text-gray-900 dark:text-white text-center placeholder:text-center placeholder:text-gray-400 dark:placeholder:text-gray-500 focus:ring-0 focus:outline-none appearance-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none" />
            <span class="text-sm text-gray-400 dark:text-gray-500 ml-1 shrink-0">{% if site_currency == 'USD' %}${% else %}{{ site_currency }}{% endif %}</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Attribute Filters -->
    {% for attribute in available_attributes %}
    {% if attribute.filtered_options %}
    <div class="filter-group py-2 border-b border-gray-100 dark:border-gray-800 last:border-b-0" data-filter-name="{{ attribute.name }}">
      <h2 id="accordion-flush-heading-attr-{{ attribute.id }}{% if is_mobile %}-mobile{% endif %}">
        <button type="button" class="flex w-full items-center justify-between font-semibold text-gray-900 hover:text-primary-700 dark:text-white dark:hover:text-primary-500 rtl:text-right cursor-pointer transition-colors" data-accordion-target="#accordion-flush-body-attr-{{ attribute.id }}{% if is_mobile %}-mobile{% endif %}" aria-expanded="true" aria-controls="accordion-flush-body-attr-{{ attribute.id }}{% if is_mobile %}-mobile{% endif %}">
          <span class="text-base">{{ attribute.name }}</span>
          <svg data-accordion-icon class="h-5 w-5 shrink-0 rotate-180" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 15 7-7 7 7" />
          </svg>
        </button>
      </h2>
      <div id="accordion-flush-body-attr-{{ attribute.id }}{% if is_mobile %}-mobile{% endif %}" class="mt-0" aria-labelledby="accordion-flush-heading-attr-{{ attribute.id }}{% if is_mobile %}-mobile{% endif %}">
        <!-- Select All / Clear Link -->
        <button type="button" 
                data-attribute-action="{{ attribute.id }}"
                data-attr-name="attr_{{ attribute.id }}"
                data-select-all-text="{% trans "Select all" %}"
                data-clear-text="{% trans "Clear" %}"
                class="text-sm text-gray-600 dark:text-gray-400 transition-colors cursor-pointer mt-1 mb-1 font-medium py-1.5 w-full text-left hover:text-primary-700 dark:hover:text-primary-500 hover:underline decoration-primary-700/30 underline-offset-4">
          <span class="action-text">{% trans "Select all" %}</span>
        </button>
        <!-- Options Container -->
        <div class="options-container space-y-0.5" data-attr-id="{{ attribute.id }}" data-collapsed="true">
          {% for option in attribute.filtered_options %}
          <label for="attr-{{ attribute.id }}-{{ option.id }}{% if is_mobile %}-mobile{% endif %}" class="flex items-center py-1.5 {% if is_mobile %}-mx-3 px-3{% else %}-mx-4 px-4{% endif %} hover:bg-gray-200 dark:hover:bg-gray-700 cursor-pointer transition-colors option-item group {% if forloop.counter > 5 %}hidden extra-option{% endif %}">
            <input id="attr-{{ attribute.id }}-{{ option.id }}{% if is_mobile %}-mobile{% endif %}" 
                   name="attr_{{ attribute.id }}" 
                   value="{{ option.slug }}" 
                   data-option-id="{{ option.id }}"
                   type="checkbox" 
                   {% if option.id in selected_attributes %}checked{% endif %}
                   class="h-4 w-4 rounded border-gray-300 bg-gray-100 text-primary-600 focus:ring-0 dark:border-gray-600 dark:bg-gray-700 dark:ring-offset-gray-800 dark:focus:ring-0 cursor-pointer shrink-0 transition-all ring-0" />
            <span class="flex-1 ms-2 text-subtitle">
              {{ option.value }}
              {% if option.product_count %}<span class="text-gray-600 dark:text-gray-400 font-medium">({{ option.product_count }})</span>{% endif %}
            </span>
          </label>
          {% endfor %}
        </div>
        <!-- Show More / Less Toggle -->
        {% if attribute.filtered_options|length > 5 %}
        <button type="button" 
                class="show-more-btn flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400 mt-1 mb-1 cursor-pointer transition-colors rounded-lg px-3 py-1.5 w-full hover:bg-gray-200 dark:hover:bg-gray-700"
                data-attr-id="{{ attribute.id }}"
                data-total="{{ attribute.filtered_options|length }}"
                data-expanded="false"
                data-more-text="{% trans "More" %}"
                data-less-text="{% trans "Less" %}">
          <span class="icon transition-transform">+</span>
          <span class="text font-medium">{% trans "More" %} ({{ attribute.filtered_options|length|add:"-5" }})</span>
        </button>
        {% endif %}
      </div>
    </div>
    {% endif %}
    {% endfor %}
  </div>

  {% if not is_mobile %}
  <!-- Apply Filters Button removed - auto-apply active -->
  {% endif %}
</div>

{% if not is_mobile %}
{% else %}
<script>
// Mobile fallback if scripts are needed
</script>
{% endif %}

{% if not is_mobile %}
<script>
// Build query string from current filter state
function buildFilterQueryString() {
  const params = new URLSearchParams();
  
  const currentUrl = new URLSearchParams(window.location.search);
  
  // Preserve per_page from current URL
  const perPage = currentUrl.get('per_page');
  if (perPage) {
    params.append('per_page', perPage);
  }

  // Preserve sort from current URL if not default
  const currentSort = currentUrl.get('sort');
  if (currentSort && currentSort !== 'relevance') {
    params.append('sort', currentSort);
  }
  
  // Add search query if present
  const searchInput = document.querySelector('input[name="q"]');
  if (searchInput && searchInput.value) {
    params.append('q', searchInput.value);
  }

  const categoryValues = currentUrl.getAll('category');
  categoryValues.forEach(function(value) {
    params.append('category', value);
  });
  
  // Collect all checked attribute checkboxes (from any active filter sidebar)
  const seen = new Set();
  document.querySelectorAll('.filters-sidebar input[name^="attr_"]:checked').forEach(function(checkbox) {
    const key = checkbox.name + '=' + checkbox.value;
    if (!seen.has(key)) {
      params.append(checkbox.name, checkbox.value);
      seen.add(key);
    }
  });
  
  // Add price filters
  const priceMin = document.getElementById('price_min') || document.getElementById('price_min_mobile');
  const priceMax = document.getElementById('price_max') || document.getElementById('price_max_mobile');
  if (priceMin && priceMin.value) {
    params.append('price_min', priceMin.value);
  }
  if (priceMax && priceMax.value) {
    params.append('price_max', priceMax.value);
  }
  
  return params.toString();
}

function getCurrencyLocale(currency) {
  const currencyLocales = {
    USD: 'en-US',
    EUR: 'de-DE',
    PLN: 'pl-PL'
  };
  return currencyLocales[currency] || 'en-US';
}

// Update Clear all link state immediately on filter changes
function updateClearAllLinkState() {
  const clearLink = document.getElementById('clear-filters-link');
  if (!clearLink) return;

  const hasSelectedAttributes = document.querySelectorAll('.filters-sidebar input[name^="attr_"]:checked').length > 0;
  const priceMin = document.getElementById('price_min') || document.getElementById('price_min_mobile');
  const priceMax = document.getElementById('price_max') || document.getElementById('price_max_mobile');
  const hasPrice = (priceMin && priceMin.value) || (priceMax && priceMax.value);
  const isActive = hasSelectedAttributes || hasPrice;

  clearLink.classList.toggle('pointer-events-none', !isActive);
  clearLink.classList.toggle('cursor-default', !isActive);
  clearLink.classList.toggle('text-gray-400', !isActive);
  clearLink.classList.toggle('dark:text-gray-500', !isActive);
  clearLink.classList.toggle('font-bold', isActive);
  clearLink.classList.toggle('cursor-pointer', isActive);
  clearLink.classList.toggle('text-gray-900', isActive);
  clearLink.classList.toggle('dark:text-white', isActive);
  clearLink.setAttribute('aria-disabled', String(!isActive));
}

let productsLoadingFailsafeTimer;
let priceDebounceTimer;
let mobileCountDebounceTimer;

// Show loading overlay on products container
function showProductsLoading(options = {}) {
  const { scrollToTop = false } = options;
  const productsContainer = document.getElementById('products-container');
  if (!productsContainer) return;

  // Create overlay (covers the products container with semi-transparent background)
  let overlay = document.getElementById('products-loading-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'products-loading-overlay';
    overlay.className = 'absolute inset-0 bg-white/50 dark:bg-gray-900/50 z-50 transition-opacity duration-200';
  }

  // Create fixed spinner (always visible on screen)
  let spinner = document.getElementById('products-loading-spinner');
  if (!spinner) {
    spinner = document.createElement('div');
    spinner.id = 'products-loading-spinner';
    spinner.className = 'fixed z-[60] -translate-x-1/2 -translate-y-1/2 pointer-events-none';
    spinner.innerHTML = `
      <div role="status">
        <svg aria-hidden="true" class="w-12 h-12 text-gray-200 animate-spin dark:text-gray-600 fill-primary-600 dark:fill-primary-500" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/>
          <path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"/>
        </svg>
        <span class="sr-only">Loading...</span>
      </div>
    `;
  }

  productsContainer.style.position = 'relative';
  productsContainer.style.minHeight = '300px';
  productsContainer.appendChild(overlay);
  document.body.appendChild(spinner);

  if (productsLoadingFailsafeTimer) {
    clearTimeout(productsLoadingFailsafeTimer);
  }
  productsLoadingFailsafeTimer = setTimeout(hideProductsLoading, 12000);

  // Scroll to top first if requested (so spinner position calculation uses correct viewport)
  if (scrollToTop) {
    window.scrollTo({ top: 0, behavior: 'auto' });
  }

  // Position spinner centered on visible portion of products container
  const updateSpinnerPosition = () => {
    const rect = productsContainer.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const spinnerSize = 48; // w-12 = 48px
    
    // Horizontal: center of products container, clamped to viewport
    const containerCenterX = rect.left + rect.width / 2;
    const clampedX = Math.max(spinnerSize / 2, Math.min(containerCenterX, window.innerWidth - spinnerSize / 2));
    spinner.style.left = `${clampedX}px`;
    
    // Vertical: center of visible portion of products container
    const visibleTop = Math.max(rect.top, 0);
    const visibleBottom = Math.min(rect.bottom, viewportHeight);
    const visibleHeight = visibleBottom - visibleTop;
    
    if (visibleHeight >= spinnerSize) {
      // Center in the visible portion of the products container.
      // When the visible slice is very small (< 30% of viewport height) the midpoint can
      // land near the very top or bottom of the screen, which looks wrong.  In that case
      // fall back to the viewport vertical centre so the spinner is always well-placed.
      const visibleCenterY = (visibleTop + visibleBottom) / 2;
      spinner.style.top = visibleHeight < viewportHeight * 0.3
        ? `${viewportHeight / 2}px`
        : `${visibleCenterY}px`;
    } else {
      // Not enough visible space - center in viewport (but in upper half for better UX)
      spinner.style.top = `${viewportHeight / 3}px`;
    }
  };

  // When scrolling to top, wait a bit for scroll to start before positioning
  if (scrollToTop) {
    setTimeout(updateSpinnerPosition, 50);
    // Also update position as scroll progresses
    const scrollHandler = () => {
      updateSpinnerPosition();
      if (window.scrollY <= 10) {
        window.removeEventListener('scroll', scrollHandler);
      }
    };
    window.addEventListener('scroll', scrollHandler, { passive: true });
  } else {
    requestAnimationFrame(updateSpinnerPosition);
  }
}

// Hide loading overlay and spinner
function hideProductsLoading() {
  if (productsLoadingFailsafeTimer) {
    clearTimeout(productsLoadingFailsafeTimer);
    productsLoadingFailsafeTimer = null;
  }

  const overlay = document.getElementById('products-loading-overlay');
  if (overlay) {
    overlay.remove();
  }
  const spinner = document.getElementById('products-loading-spinner');
  if (spinner) {
    spinner.remove();
  }
}

function cancelPendingFilterTimers() {
  if (priceDebounceTimer) {
    clearTimeout(priceDebounceTimer);
    priceDebounceTimer = null;
  }
  if (mobileCountDebounceTimer) {
    clearTimeout(mobileCountDebounceTimer);
    mobileCountDebounceTimer = null;
  }
}

// Update all product count displays
function updateProductCounts() {
  const countElement = document.getElementById('product-count-data');
  if (!countElement) return;
  
  const count = countElement.getAttribute('data-total-count');
  if (!count) return;
  
  const countNum = parseInt(count, 10);
  
  // Update mobile results count
  const mobileCountSpan = document.getElementById('mobile-results-count');
  if (mobileCountSpan) {
    mobileCountSpan.textContent = count;
  }
  
  // Update category product count in sidebar
  const categoryCount = document.getElementById('category-product-count');
  if (categoryCount) {
    categoryCount.textContent = '(' + count + ')';
  }
  const categoryCountMobile = document.getElementById('category-product-count-mobile');
  if (categoryCountMobile) {
    categoryCountMobile.textContent = '(' + count + ')';
  }
  
  // Update main header "X products found" text
  const productsFoundText = document.getElementById('products-found-text');
  if (productsFoundText) {
    const singular = productsFoundText.getAttribute('data-singular') || 'product found';
    const plural = productsFoundText.getAttribute('data-plural') || 'products found';
    productsFoundText.textContent = count + ' ' + (countNum === 1 ? singular : plural);
  }
}

// Apply filters using fetch API (no page reload, no scroll jump)
function applyFiltersWithHtmx(options = {}) {
  const { scrollToTop = false } = options;
  updateClearAllLinkState();
  const queryString = buildFilterQueryString();
  const baseUrl = window.location.pathname;
  const newUrl = queryString ? `${baseUrl}?${queryString}` : baseUrl;
  
  // Update browser URL without reload
  window.history.pushState({}, '', newUrl);
  
  // Show loading indicator
  showProductsLoading({ scrollToTop });
  
  // Use HTMX (preferred) or fetch API to get and update only the products container
  const productsContainer = document.getElementById('products-container');
  if (productsContainer) {
    if (window.htmx && typeof window.htmx.ajax === 'function') {
      const request = window.htmx.ajax('GET', newUrl, {
        target: '#products-container',
        swap: 'innerHTML'
      });
      if (request && typeof request.catch === 'function') {
        request.catch(function() {
          hideProductsLoading();
        });
      }
    } else {
      fetch(newUrl, {
        headers: {
          'HX-Request': 'true'
        }
      })
      .then(response => response.text())
      .then(html => {
        productsContainer.innerHTML = html;
        hideProductsLoading();
        // Re-trigger price formatting
        document.querySelectorAll('#products-container [data-price]').forEach(function(el) {
          const price = parseFloat(el.dataset.price);
          const currency = el.dataset.currency || '{{ site_currency|default:"USD" }}';
          const locale = getCurrencyLocale(currency);
          if (!isNaN(price)) {
            el.textContent = new Intl.NumberFormat(locale, {
              style: 'currency',
              currency: currency
            }).format(price);
          }
        });
        // Re-initialize Flowbite components
        if (typeof initFlowbite === 'function') {
          initFlowbite();
        }
        if (typeof handleResponsiveView === 'function') {
          handleResponsiveView();
        }
        // Reinitialize category recommended products Swiper
        if (typeof window.initCategoryRecommendedSlider === 'function') {
          window.initCategoryRecommendedSlider();
        }
        // Re-attach pagination listeners
        initPaginationLinks();
        // Re-attach active filter chip listeners
        initActiveFilterChips();
        // Update all product counts
        updateProductCounts();
      })
      .catch(error => {
        console.error('Error fetching products:', error);
        hideProductsLoading();
      });
    }
  }
}

// Navigate to a page using AJAX with loader
function navigateToPage(url, options = {}) {
  // Prevent delayed debounce callbacks (price/mobile-count) from dispatching
  // a second request right after explicit navigations like "Clear all".
  cancelPendingFilterTimers();

  // Update browser URL without reload
  window.history.pushState({}, '', url);
  
  // Show loading indicator
  showProductsLoading(options);
  
  // Use HTMX (preferred) or fetch API to get and update only the products container
  const productsContainer = document.getElementById('products-container');
  if (productsContainer) {
    if (window.htmx && typeof window.htmx.ajax === 'function') {
      const request = window.htmx.ajax('GET', url, {
        target: '#products-container',
        swap: 'innerHTML'
      });
      if (request && typeof request.then === 'function') {
        request.then(function() {
          // Ensure counts are updated after HTMX swap
          updateProductCounts();
        });
      }
      if (request && typeof request.catch === 'function') {
        request.catch(function() {
          hideProductsLoading();
        });
      }
    } else {
      fetch(url, {
        headers: {
          'HX-Request': 'true'
        }
      })
      .then(response => response.text())
      .then(html => {
        productsContainer.innerHTML = html;
        hideProductsLoading();
        // Re-trigger price formatting
        document.querySelectorAll('#products-container [data-price]').forEach(function(el) {
          const price = parseFloat(el.dataset.price);
          const currency = el.dataset.currency || '{{ site_currency|default:"USD" }}';
          const locale = getCurrencyLocale(currency);
          if (!isNaN(price)) {
            el.textContent = new Intl.NumberFormat(locale, {
              style: 'currency',
              currency: currency
            }).format(price);
          }
        });
        // Re-initialize Flowbite components
        if (typeof initFlowbite === 'function') {
          initFlowbite();
        }
        if (typeof handleResponsiveView === 'function') {
          handleResponsiveView();
        }
        // Reinitialize category recommended products Swiper
        if (typeof window.initCategoryRecommendedSlider === 'function') {
          window.initCategoryRecommendedSlider();
        }
        // Re-attach pagination listeners
        initPaginationLinks();
        // Re-attach active filter chip listeners
        initActiveFilterChips();
        // Update all product counts
        updateProductCounts();
      })
      .catch(error => {
        console.error('Error fetching products:', error);
        hideProductsLoading();
      });
    }
  }
}

// Initialize pagination link handlers
function initPaginationLinks() {
  if (window.htmx) return;
  document.querySelectorAll('[data-pagination-link]').forEach(function(link) {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      navigateToPage(this.href, { scrollToTop: true, positionMode: 'first-item' });
    });
  });
}

// Initialize active filter chip click handlers (event delegation — DOM-order independent)
function initActiveFilterChips() {
  // Guard: set up delegation only once per page lifecycle (persists across soft-nav swaps)
  if (document.body.dataset.filterChipsDelegationSetup) return;
  document.body.dataset.filterChipsDelegationSetup = '1';

  // Delegated: individual filter chip removal ([data-remove-filter])
  document.addEventListener('click', function(e) {
    const chip = e.target.closest('[data-remove-filter]');
    if (!chip) return;
    e.preventDefault();
    const filterType = chip.getAttribute('data-filter-type');
    const filterValue = chip.getAttribute('data-filter-value');

    const urlParams = new URLSearchParams(window.location.search);

    if (filterType === 'price_min') {
      urlParams.delete('price_min');
      const priceMinInput = document.getElementById('price_min');
      if (priceMinInput) priceMinInput.value = '';
    } else if (filterType === 'price_max') {
      urlParams.delete('price_max');
      const priceMaxInput = document.getElementById('price_max');
      if (priceMaxInput) priceMaxInput.value = '';
    } else if (filterType.startsWith('attr_')) {
      const currentValues = urlParams.getAll(filterType);
      urlParams.delete(filterType);
      currentValues.forEach(function(val) {
        if (val !== filterValue) {
          urlParams.append(filterType, val);
        }
      });
      document.querySelectorAll('.filters-sidebar input[name="' + filterType + '"][value="' + filterValue + '"]').forEach(function(checkbox) {
        checkbox.checked = false;
      });
    }

    urlParams.delete('page');
    const baseUrl = window.location.pathname;
    const newUrl = urlParams.toString() ? `${baseUrl}?${urlParams.toString()}` : baseUrl;
    updateClearAllLinkState();
    navigateToPage(newUrl);
  });

  // Delegated: clear all filters ([data-clear-all-filters])
  document.addEventListener('click', function(e) {
    const btn = e.target.closest('[data-clear-all-filters]');
    if (!btn) return;
    // Skip disabled state (desktop clear-all link when no filters are active)
    if (btn.classList.contains('pointer-events-none')) return;
    e.preventDefault();

    const baseUrl = btn.getAttribute('data-base-url') || window.location.pathname;
    const urlParams = new URLSearchParams(window.location.search);
    const searchQuery = urlParams.get('q');
    const searchPath = '{% url "web:search_results" %}';
    const searchCategory = baseUrl === searchPath ? urlParams.get('category') : '';
    const newParams = new URLSearchParams();
    if (searchQuery) {
      newParams.set('q', searchQuery);
    }
    if (searchCategory) {
      newParams.set('category', searchCategory);
    }
    const newUrl = newParams.toString() ? `${baseUrl}?${newParams.toString()}` : baseUrl;

    // Clear all filter inputs in desktop sidebar
    document.querySelectorAll('#filters-sidebar input[name^="attr_"]').forEach(function(cb) {
      cb.checked = false;
    });
    // Clear all filter inputs in mobile drawer
    document.querySelectorAll('#filters-sidebar-mobile input[name^="attr_"]').forEach(function(cb) {
      cb.checked = false;
    });
    // Clear desktop price inputs
    const priceMinInput = document.getElementById('price_min');
    const priceMaxInput = document.getElementById('price_max');
    if (priceMinInput) priceMinInput.value = '';
    if (priceMaxInput) priceMaxInput.value = '';
    // Clear mobile price inputs
    const priceMinMobileInput = document.getElementById('price_min_mobile');
    const priceMaxMobileInput = document.getElementById('price_max_mobile');
    if (priceMinMobileInput) priceMinMobileInput.value = '';
    if (priceMaxMobileInput) priceMaxMobileInput.value = '';

    // Close mobile filter drawer if this button lives inside it
    const mobileFilterDrawer = document.getElementById('drawer-mobile-filter');
    if (mobileFilterDrawer && mobileFilterDrawer.contains(btn)) {
      const dismissBtn = mobileFilterDrawer.querySelector('[data-drawer-dismiss="drawer-mobile-filter"]');
      if (dismissBtn) dismissBtn.click();
    }

    updateClearAllLinkState();
    navigateToPage(newUrl);
  });
}

// Debounce function for price inputs
function debouncedApplyFilters() {
  clearTimeout(priceDebounceTimer);
  priceDebounceTimer = setTimeout(applyFiltersWithHtmx, 800);
}

// Mobile results count preview - fetch count without applying filters
function debouncedUpdateMobileResultsCount() {
  clearTimeout(mobileCountDebounceTimer);
  mobileCountDebounceTimer = setTimeout(updateMobileResultsCount, 300);
}

function updateMobileResultsCount() {
  const mobileCountSpan = document.getElementById('mobile-results-count');
  if (!mobileCountSpan) return;
  
  const queryString = buildFilterQueryString();
  const baseUrl = window.location.pathname;
  const requestUrl = queryString ? `${baseUrl}?${queryString}` : baseUrl;
  
  // Show loading indicator on the button
  const originalText = mobileCountSpan.textContent;
  mobileCountSpan.textContent = '...';
  
  fetch(requestUrl, {
    headers: {
      'HX-Request': 'true'
    }
  })
  .then(response => response.text())
  .then(html => {
    // Parse the response to extract the count from data attribute
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const countElement = doc.getElementById('product-count-data');
    if (countElement) {
      const count = countElement.getAttribute('data-total-count');
      mobileCountSpan.textContent = count || '0';
    } else {
      // Fallback: try to count products or restore original
      mobileCountSpan.textContent = originalText;
    }
  })
  .catch(error => {
    console.error('Error fetching product count:', error);
    mobileCountSpan.textContent = originalText;
  });
}

// Filter search functionality — runs immediately so it works after HTMX soft-nav swaps
(function() {
  // Expand all accordions by default (both desktop and mobile)
  document.querySelectorAll('#accordion-flush [data-accordion-target], #accordion-flush-mobile [data-accordion-target]').forEach(function(button) {
    const targetId = button.getAttribute('data-accordion-target');
    const target = document.querySelector(targetId);
    const icon = button.querySelector('[data-accordion-icon]');
    
    if (target) {
      // Expand: remove hidden, set aria-expanded true, rotate icon
      target.classList.remove('hidden');
      button.setAttribute('aria-expanded', 'true');
      if (icon) icon.classList.add('rotate-180');
    }
  });

  // NOTE: filter-search-input listener is delegated globally below (filterGlobalListenersAttached guard)
  
  // Function to update attribute action link text (Select all / Clear)
  function updateAttributeActionLink(attrId) {
    // Update action buttons in all sidebars (desktop and mobile)
    document.querySelectorAll('.filters-sidebar').forEach(function(sidebar) {
      const actionBtn = sidebar.querySelector('[data-attribute-action="' + attrId + '"]');
      if (!actionBtn) return;
      
      const actionTextSpan = actionBtn.querySelector('.action-text');
      const attrName = actionBtn.getAttribute('data-attr-name');
      const selectAllText = actionBtn.getAttribute('data-select-all-text') || 'Select all';
      const clearText = actionBtn.getAttribute('data-clear-text') || 'Clear';
      
      // Count checkboxes only within this specific sidebar container
      const checkedCount = sidebar.querySelectorAll('input[name="' + attrName + '"]:checked').length;
      
      if (checkedCount > 0) {
        actionTextSpan.textContent = clearText + ' (' + checkedCount + ')';
      } else {
        actionTextSpan.textContent = selectAllText;
      }
    });
  }

  function toggleAttributeFromTile(attrId, optionSlug) {
    const desktopSidebar = document.getElementById('filters-sidebar');
    if (!desktopSidebar) return;

    const attrName = 'attr_' + attrId;
    const desktopCheckbox = desktopSidebar.querySelector('input[name="' + attrName + '"][value="' + optionSlug + '"]');
    const mobileSidebar = document.getElementById('filters-sidebar-mobile');
    const mobileCheckbox = mobileSidebar ? mobileSidebar.querySelector('input[name="' + attrName + '"][value="' + optionSlug + '"]') : null;
    const targetCheckbox = desktopCheckbox || mobileCheckbox;
    if (!targetCheckbox) return;

    const newChecked = !targetCheckbox.checked;
    if (desktopCheckbox) desktopCheckbox.checked = newChecked;
    if (mobileCheckbox) mobileCheckbox.checked = newChecked;

    // Update attribute action link and apply filters with scroll to top
    // (clicking on product tile attributes should scroll to top of page)
    updateAttributeActionLink(attrId);
    updateClearAllLinkState();
    applyFiltersWithHtmx({ scrollToTop: true });
  }

  function handleTileAttributeActivation(target, event) {
    const productsContainer = document.getElementById('products-container');
    const desktopSidebar = document.getElementById('filters-sidebar');
    if (!productsContainer || !desktopSidebar) return;

    const attrId = target.getAttribute('data-attr-id');
    const optionSlug = target.getAttribute('data-option-slug');
    if (!attrId || !optionSlug) return;

    event.preventDefault();
    event.stopPropagation();
    toggleAttributeFromTile(attrId, optionSlug);
  }

  // Guard: document-level listeners must only be attached once across soft-nav swaps.
  // ALL listeners on specific elements (accordion, price inputs, search, attribute-action
  // buttons) are placed here because HTMX executes inline scripts on pre-swap DOM elements,
  // meaning any direct getElementById/querySelectorAll bindings target elements that get
  // removed by the swap. Event delegation on document survives all swaps.
  if (!document.body.dataset.filterGlobalListenersAttached) {
    document.body.dataset.filterGlobalListenersAttached = '1';

    // Product tile attribute pill clicks
    document.addEventListener('click', function(event) {
      const target = event.target.closest('[data-attr-id][data-option-slug]');
      if (!target) return;
      handleTileAttributeActivation(target, event);
    });
    document.addEventListener('keydown', function(event) {
      if (event.key !== 'Enter' && event.key !== ' ') return;
      const target = event.target.closest('[data-attr-id][data-option-slug]');
      if (!target) return;
      handleTileAttributeActivation(target, event);
    });

    // Desktop accordion checkbox changes → auto-apply filters
    document.addEventListener('change', function(event) {
      if (!event.target.closest('#accordion-flush')) return;
      if (!event.target.matches('input[name^="attr_"]')) return;
      const attrName = event.target.name;
      const attrId = attrName.replace('attr_', '');
      // Sync with mobile if it exists
      const mobileSidebar = document.getElementById('filters-sidebar-mobile');
      if (mobileSidebar) {
        const mobileCheckbox = mobileSidebar.querySelector('input[name="' + attrName + '"][value="' + event.target.value + '"]');
        if (mobileCheckbox) mobileCheckbox.checked = event.target.checked;
      }
      updateAttributeActionLink(attrId);
      updateClearAllLinkState();
      applyFiltersWithHtmx();
    });

    // Mobile accordion checkbox changes → sync desktop, update count preview
    document.addEventListener('change', function(event) {
      if (!event.target.closest('#accordion-flush-mobile')) return;
      if (!event.target.matches('input[name^="attr_"]')) return;
      const attrName = event.target.name;
      const attrId = attrName.replace('attr_', '');
      const desktopSidebar = document.getElementById('filters-sidebar');
      if (desktopSidebar) {
        const desktopCheckbox = desktopSidebar.querySelector('input[name="' + attrName + '"][value="' + event.target.value + '"]');
        if (desktopCheckbox) desktopCheckbox.checked = event.target.checked;
      }
      updateAttributeActionLink(attrId);
      updateClearAllLinkState();
      debouncedUpdateMobileResultsCount();
    });

    // Price input changes → sync mobile/desktop, auto-apply (desktop) or update count (mobile)
    document.addEventListener('input', function(event) {
      const id = event.target.id;
      if (id === 'price_min') {
        const mob = document.getElementById('price_min_mobile');
        if (mob) mob.value = event.target.value;
        updateClearAllLinkState();
        debouncedApplyFilters();
      } else if (id === 'price_max') {
        const mob = document.getElementById('price_max_mobile');
        if (mob) mob.value = event.target.value;
        updateClearAllLinkState();
        debouncedApplyFilters();
      } else if (id === 'price_min_mobile') {
        const desk = document.getElementById('price_min');
        if (desk) desk.value = event.target.value;
        updateClearAllLinkState();
        debouncedUpdateMobileResultsCount();
      } else if (id === 'price_max_mobile') {
        const desk = document.getElementById('price_max');
        if (desk) desk.value = event.target.value;
        updateClearAllLinkState();
        debouncedUpdateMobileResultsCount();
      }
    });

    // Filter search input → live filter group/option visibility
    document.addEventListener('input', function(event) {
      if (event.target.id !== 'filter-search-input') return;
      const query = event.target.value.toLowerCase().trim();
      document.querySelectorAll('.filter-group').forEach(function(group) {
        const filterName = group.getAttribute('data-filter-name').toLowerCase();
        if (query === '' || filterName.includes(query)) {
          group.style.display = '';
          group.querySelectorAll('[id^="attr-"]').forEach(function(checkbox) {
            const optionRow = checkbox.closest('label');
            if (optionRow) optionRow.style.display = '';
          });
        } else {
          let hasMatch = false;
          group.querySelectorAll('[id^="attr-"]').forEach(function(checkbox) {
            const optionRow = checkbox.closest('label');
            const text = optionRow ? optionRow.textContent.toLowerCase() : '';
            if (text.includes(query)) {
              if (optionRow) optionRow.style.display = '';
              hasMatch = true;
            } else {
              if (optionRow) optionRow.style.display = 'none';
            }
          });
          group.style.display = hasMatch ? '' : 'none';
        }
      });
    });

    // Attribute-action button (Select all / Clear) clicks
    document.addEventListener('click', function(event) {
      const btn = event.target.closest('[data-attribute-action]');
      if (!btn) return;
      event.preventDefault();
      event.stopPropagation();
      const attrId = btn.getAttribute('data-attribute-action');
      const attrName = btn.getAttribute('data-attr-name');
      const sidebar = btn.closest('.filters-sidebar');
      if (!sidebar) return;
      const checkboxes = sidebar.querySelectorAll('input[name="' + attrName + '"]');
      const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
      if (checkedCount > 0) {
        checkboxes.forEach(function(cb) { cb.checked = false; });
      } else {
        checkboxes.forEach(function(cb) { cb.checked = true; });
      }
      const isMobileSidebar = sidebar.id.includes('mobile');
      const otherSidebarId = isMobileSidebar ? 'filters-sidebar' : 'filters-sidebar-mobile';
      const otherSidebar = document.getElementById(otherSidebarId);
      if (otherSidebar) {
        const otherCheckboxes = otherSidebar.querySelectorAll('input[name="' + attrName + '"]');
        otherCheckboxes.forEach((cb, index) => {
          if (checkboxes[index]) cb.checked = checkboxes[index].checked;
        });
      }
      updateAttributeActionLink(attrId);
      updateClearAllLinkState();
      if (!isMobileSidebar) {
        applyFiltersWithHtmx();
      }
    });
  }

  // Initialize attribute action link labels based on current checked state (server render).
  // Click handling is now delegated globally in the filterGlobalListenersAttached guard above.
  document.querySelectorAll('[data-attribute-action]').forEach(function(btn) {
    const attrId = btn.getAttribute('data-attribute-action');
    updateAttributeActionLink(attrId);
  });
  
  // NOTE: accordion change, mobile accordion change, and price input listeners are now
  // all handled by document-level delegation in the filterGlobalListenersAttached guard above.
  // The old direct getElementById bindings (desktopAccordion, mobileAccordion, priceMin, etc.)
  // were removed because HTMX executes inline scripts on pre-swap elements — those bindings
  // targeted elements that get replaced, so they stopped working after soft-nav.

  // Note: Click handling for option rows is now done via label elements wrapping checkboxes
  
  // Show More / Less toggle functionality (event delegation — HTMX runs scripts on
  // temporary elements before the final innerHTML swap, so direct listeners on the
  // queried elements get lost; using document-level delegation avoids that entirely).
  if (!document.body.dataset.filterShowMoreAttached) {
    document.body.dataset.filterShowMoreAttached = '1';
    document.addEventListener('click', function(event) {
      const btn = event.target.closest('.show-more-btn');
      if (!btn) return;
      const group = btn.closest('.filter-group');
      const container = group.querySelector('.options-container');
      const extraOptions = container.querySelectorAll('.extra-option');
      const isExpanded = btn.getAttribute('data-expanded') === 'true';
      const iconSpan = btn.querySelector('.icon');
      const textSpan = btn.querySelector('.text');

      const moreText = btn.getAttribute('data-more-text') || 'More';
      const lessText = btn.getAttribute('data-less-text') || 'Less';
      const total = parseInt(btn.getAttribute('data-total'));
      const hiddenCount = total - 5;

      if (isExpanded) {
        // Collapse
        extraOptions.forEach(function(opt) {
          opt.classList.add('hidden');
        });
        btn.setAttribute('data-expanded', 'false');
        iconSpan.textContent = '+';
        textSpan.textContent = moreText + ' (' + hiddenCount + ')';
      } else {
        // Expand
        extraOptions.forEach(function(opt) {
          opt.classList.remove('hidden');
        });
        btn.setAttribute('data-expanded', 'true');
        iconSpan.textContent = '—';
        textSpan.textContent = lessText;
      }
    });
  }
  
  // Custom accordion toggle for filter accordions (event delegation for same reason as show-more-btn)
  if (!document.body.dataset.filterAccordionAttached) {
    document.body.dataset.filterAccordionAttached = '1';
    document.addEventListener('click', function(event) {
      const button = event.target.closest('[data-accordion-target]');
      if (!button) return;
      // Only handle filter accordion buttons (not other accordions on the page)
      if (!button.closest('#accordion-flush, #accordion-flush-mobile')) return;
      event.preventDefault();
      const targetId = button.getAttribute('data-accordion-target');
      const target = document.querySelector(targetId);
      const icon = button.querySelector('[data-accordion-icon]');

      if (target) {
        const isHidden = target.classList.contains('hidden');
        if (isHidden) {
          target.classList.remove('hidden');
          button.setAttribute('aria-expanded', 'true');
          if (icon) icon.classList.add('rotate-180');
        } else {
          target.classList.add('hidden');
          button.setAttribute('aria-expanded', 'false');
          if (icon) icon.classList.remove('rotate-180');
        }
      }
    });
  }

  // Initialize pagination link handlers
  initPaginationLinks();
  
  // Initialize active filter chip handlers
  initActiveFilterChips();

  // Initialize Clear all state on first load
  updateClearAllLinkState();

  // HTMX hooks for loader + re-init (guarded to prevent accumulation across soft-nav swaps).
  // Attach unconditionally: HTMX is loaded with `defer`, so `window.htmx` may be undefined
  // when this inline script runs during HTML parsing.
  if (!document.body.dataset.filterHtmxHooksAttached) {
    document.body.dataset.filterHtmxHooksAttached = '1';
    document.addEventListener('htmx:beforeRequest', function(e) {
      const trigger = e.detail.elt;
      if (!trigger) return;
      const targetId = e.detail.target && e.detail.target.id;
      const isPaginationOrSort =
        (typeof trigger.matches === 'function' && trigger.matches('[data-pagination-link], [data-sort-link]')) ||
        (typeof trigger.closest === 'function' && !!trigger.closest('[data-pagination-link], [data-sort-link]'));
      
      // Show loader for any request targeting products-container
      if (targetId === 'products-container') {
        if (document.getElementById('products-loading-spinner')) return;
        if (isPaginationOrSort) {
          showProductsLoading({ scrollToTop: true, positionMode: 'visible-center' });
        } else {
          showProductsLoading({ scrollToTop: false, positionMode: 'visible-center' });
        }
      }
    });

    document.addEventListener('htmx:afterSwap', function(e) {
      if (e.target && e.target.id === 'products-container') {
        hideProductsLoading();
        if (typeof initFlowbite === 'function') {
          initFlowbite();
        }
        if (typeof initSortDropdownAnimation === 'function') {
          initSortDropdownAnimation();
        }
        if (typeof handleResponsiveView === 'function') {
          handleResponsiveView();
        }
        // Reinitialize category recommended products Swiper after HTMX swap
        if (typeof window.initCategoryRecommendedSlider === 'function') {
          window.initCategoryRecommendedSlider();
        }
        initActiveFilterChips();
        updateClearAllLinkState();
        
        // Update all product counts
        updateProductCounts();
      }
    });
    
    document.addEventListener('htmx:responseError', function(e) {
      if (e.target && e.target.id === 'products-container') {
        hideProductsLoading();
      }
    });

    document.addEventListener('htmx:afterRequest', function(e) {
      const targetId = e.detail && e.detail.target && e.detail.target.id;
      if (targetId === 'products-container') {
        hideProductsLoading();
      }
    });

    document.addEventListener('htmx:sendError', function(e) {
      const targetId = e.detail && e.detail.target && e.detail.target.id;
      if (targetId === 'products-container') {
        hideProductsLoading();
      }
    });

    document.addEventListener('htmx:timeout', function(e) {
      const targetId = e.detail && e.detail.target && e.detail.target.id;
      if (targetId === 'products-container') {
        hideProductsLoading();
      }
    });

    document.addEventListener('htmx:historyRestore', function() {
      hideProductsLoading();
      initActiveFilterChips();
      updateClearAllLinkState();
      updateProductCounts();
    });

    window.addEventListener('popstate', function() {
      hideProductsLoading();
    });
  }

})();
</script>
{% endif %}
